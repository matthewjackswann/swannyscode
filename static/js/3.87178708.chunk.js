(this.webpackJsonpswannyscode=this.webpackJsonpswannyscode||[]).push([[3],{162:function(e,t,n){"use strict";n.r(t);var s,r=n(13),c=n(8),i=n(1),a=n(95),o=n(14),h=n(415),l=n.n(h),d=n(0),x=function(e,t){var n=Object(i.useState)(""),s=Object(c.a)(n,2),r=s[0],a=s[1],o=function(e){for(var t="",n=0;n<e.length;n++)t+=e.charCodeAt(n).toString(16);for(var s,r=(s=parseInt(t,16)%0x1cc71b7bf6787900,function(){return(s=1e4*Math.sin(s))-Math.floor(s)}),c="",i=0;i<8;i++)c+="abcdefghijklmnopqrstuvwxyz".charAt(Math.floor(26*r()));return c},h=r+t,l=e?r+"????????????????????????":h,x=o(h.slice(0,8))+o(h.slice(8,16))+o(h.slice(16,24));return Object(d.jsxs)("div",{children:[Object(d.jsxs)("p",{children:["Message to encrypt: ",Object(d.jsx)("input",{type:"text",value:r,onChange:function(e){return a(e.target.value.toLowerCase())}})]}),Object(d.jsxs)("table",{style:{borderSpacing:0},children:[Object(d.jsx)("colgroup",{children:Array.from(Array(24).keys()).map((function(e){var t=e>7&&e<16?"rgba(255,0,0,.25)":"rgba(0,255,0,.25)";return Object(d.jsx)("col",{style:{backgroundColor:t}},e)}))}),Object(d.jsxs)("tbody",{children:[Object(d.jsx)("tr",{children:Array.from(Array(24).keys()).map((function(e){return e>=r.length?Object(d.jsx)("td",{style:{width:"2%",padding:"0px",textAlign:"center"},children:Object(d.jsx)("b",{children:Object(d.jsx)("span",{style:{color:"red"},children:l[e]})})},e):Object(d.jsx)("td",{style:{width:"2%",padding:"0px",textAlign:"center"},children:Object(d.jsx)("b",{children:Object(d.jsx)("span",{style:{color:"blue"},children:l[e]})})},e)}))}),Object(d.jsx)("tr",{children:Array.from(Array(21).keys()).map((function(e){return(e+4)%7===0?Object(d.jsx)("td",{colSpan:"2",style:{width:"2%",padding:"0px",textAlign:"center",height:"10px"},children:Object(d.jsx)("span",{children:"\u21a7"})},e):Object(d.jsx)("td",{style:{width:"2%",padding:"0px",height:"10px"}},e)}))}),Object(d.jsx)("tr",{children:Array.from(Array(24).keys()).map((function(e){return Object(d.jsx)("td",{style:{width:"2%",padding:"0px",textAlign:"center"},children:Object(d.jsx)("b",{children:x[e]})},e)}))})]})]})]})};t.default=function(){return Object(d.jsxs)("div",{children:[Object(d.jsx)("h1",{children:"AES CBC with predictable IV"}),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"This is a cryptography challenge I came across competing in a competition. We aren't allowed to share the question or solution but I enjoyed it so much I made my own version. It is still based of exploiting the same vulnerability, the predictable IV."}),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"We are given a server ip address and port to connect to and the servers code."}),Object(d.jsxs)(a.a,{children:[Object(d.jsx)("h4",{children:"server.py"}),Object(d.jsx)("div",{className:"code",children:Object(d.jsx)("code",{className:"prettyprint",children:"import socket\nimport os\nfrom Crypto.Cipher import AES\n\n# A different flag is used in the real server :)\n# the character set is uppercase letters and space.\n# The real one is not necessarily this long.\nFLAG = b'THIS IS MY SECRET MESSAGE'\n\n# A different encryption key is used in the real server :)\nENCRYPT_KEY = b'ThisIsNotTheSecretKey...'\nBLOCK_SIZE = 16\n\ndef pad_to_full_block(data):\n    padding_len = BLOCK_SIZE - (len(data) % BLOCK_SIZE)\n    return data + str.encode(chr(padding_len) * padding_len)\n\ndef encrypt(data, iv):\n    aes = AES.new(ENCRYPT_KEY, AES.MODE_CBC, iv)\n    padded = pad_to_full_block(data)\n    return aes.encrypt(pad_to_full_block(data))\n\nHOST = '127.0.0.1'\nPORT = 65432\n\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n    s.bind((HOST, PORT))\n    s.listen()\n    conn, addr = s.accept()\n    with conn:\n        print('Connected by', addr)\n        iv = os.urandom(16)\n        conn.sendall(iv)\n        while True:\n            try:\n                data = conn.recv(4096)\n                encryptingMessage = data + FLAG\n                toSend = encrypt(encryptingMessage, iv)\n                iv = toSend[-16:]\n                conn.sendall(toSend)\n            except:\n                break\n"})})]}),Object(d.jsx)("p",{children:"Looking through the code we can see that this is some form of AES encryption service using CBC. We are also given the initial IV when we first connect."}),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"We can also see that there is no information given about the key used which implies that we don't want to try and guess the key and we might be able to work out the flag without the key."}),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"Next it's best to look at how AES CBC works and if there are any vulnerabilities we can use."}),Object(d.jsx)("img",{src:"https://upload.wikimedia.org/wikipedia/commons/8/80/CBC_encryption.svg",alt:"cbc structure"}),Object(d.jsx)("p",{children:"The message we want to encrypt (the plaintext) is split into blocks of 16. The first block and the IV are combined with a bitwise xor and then the result in encrypted. This result makes up the first block of the ciphertext and is used in the xor with the second block. This continues for each block until the entire plaintext is converted into ciphertext."}),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"This is all the information we need to be able to crack the first part of this challenge, making the IV effectively redundant. This is done using the following property of the xor operator."}),Object(d.jsx)(o.a,{tex:String.raw(s||(s=Object(r.a)(["alpha oplus \beta = 0 Leftrightarrow alpha = \beta"],["\\alpha \\oplus \\beta = 0 \\Leftrightarrow \\alpha = \\beta"])))}),Object(d.jsx)("p",{children:"This means that if we set the first block equal to the IV then the xor of this will be 0. When this is encrypted by AES and a constant key the out put will always be the same. This then means that when the second block is combined with the ciphertext, the ciphertext is constant and we can treat the second block as the first, just now with a constant IV."}),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"In summary, if we put the next IV at the start of our message to the server then the encrypted message will always be the same, removing the randomness that is usually made by the IV."}),Object(d.jsx)("br",{}),Object(d.jsxs)("p",{children:["This allows us the guess the second block. If we send ",Object(d.jsx)("b",{children:"IV"})," to the server then look at the output of the second block we have our target. We can then send ",Object(d.jsx)("b",{children:"IV + guess"})," to the server and if the second block of the ciphertext matches our target we know that our guess is correct and we can continue onto the next block until all blocks have been cracked."]}),Object(d.jsx)("br",{}),Object(d.jsxs)("p",{children:["This sounds great but even with the restricted alphabet that we are guessing for there are still ",Object(d.jsxs)("b",{children:["3.2452x10",Object(d.jsx)("sup",{children:"32"})]})," different guesses. This is way to many to guess all of them so we can reduce this by only guessing one character at a time. If you want to try and work out how it can be done quite cleverly by taking advantage of how our message is combined with the flag on the server."]}),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"If you've not worked it out (or just can't be bothered) we can guess only one letter at a time by filling the rest of the plaintext with known values and having the last character of the block be the first character of the flag. Then we can guess the last character and move onto the next character."}),Object(d.jsx)("br",{}),Object(d.jsxs)("p",{children:["Example",Object(d.jsx)("br",{}),"If we send to the server the following message:"]}),Object(d.jsxs)("p",{children:[Object(d.jsx)("b",{children:"IV"})," + xxxxxxxxxxxxxxx"]}),Object(d.jsx)("p",{children:"Then the first two block will be the encrypted version of the plaintext"}),Object(d.jsxs)("p",{children:[Object(d.jsx)("b",{children:"IV"})," + xxxxxxxxxxxxxxx?"]}),Object(d.jsxs)("p",{children:["Where ",Object(d.jsx)("b",{children:"?"})," is the first character of the flag, this is our target."]}),Object(d.jsxs)("p",{children:["To find the value of ",Object(d.jsx)("b",{children:"?"})," we can next send the messages"]}),Object(d.jsxs)("p",{children:[Object(d.jsx)("b",{children:"IV"})," + xxxxxxxxxxxxxxxA, ",Object(d.jsx)("b",{children:"IV"})," + xxxxxxxxxxxxxxxB, ",Object(d.jsx)("b",{children:"IV"})," + xxxxxxxxxxxxxxxC ..."]}),Object(d.jsx)("p",{children:"As soon as the second block of ciphertext matches our target we know that our guess was correct and we can move onto the next character."}),Object(d.jsx)("br",{}),Object(d.jsxs)("p",{children:["Using this method we only have to make at most ",Object(d.jsx)(l.a,{display:"inline",latex:"\\text{alphabet size} * \\text{flag length}"}),". This is far smaller then the previous ",Object(d.jsx)(l.a,{display:"inline",latex:"\\text{block size} ^ \\text{alphabet size} * \\text{blocks in flag}"}),". We will use this method to work out what the flag is."]}),Object(d.jsx)("br",{}),Object(d.jsxs)("p",{children:["I've made an interactive example of how this process works below. It doesn't use the same encryption methods but the same methodology applies. ",Object(d.jsx)("b",{children:Object(d.jsx)("span",{style:{color:"red"},children:"Red"})})," characters and 'unknown' from the flag and ",Object(d.jsx)("b",{children:Object(d.jsx)("span",{style:{color:"blue"},children:"Blue"})})," characters are from your message input. For simplicity the ",Object(d.jsx)("b",{children:"IV"})," is fixed so can be ignored and the block size is 8 rather than the standard 16."]}),Object(d.jsx)("br",{}),x(!1,"secure super secret flag"),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"To get an understanding of how this works try entering the following while looking at the output:"}),Object(d.jsxs)("ul",{children:[Object(d.jsx)("li",{children:Object(d.jsx)("b",{children:"xxxxxxx"})}),Object(d.jsx)("li",{children:Object(d.jsx)("b",{children:"xxxxxxxs"})})]}),Object(d.jsx)("p",{children:"And then"}),Object(d.jsxs)("ul",{children:[Object(d.jsx)("li",{children:Object(d.jsx)("b",{children:"xxxxxx"})}),Object(d.jsx)("li",{children:Object(d.jsx)("b",{children:"xxxxxxse"})})]}),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"As you can see the first blocks output is the same so you can work out the first block. To then work out the second try entering:"}),Object(d.jsxs)("ul",{children:[Object(d.jsx)("li",{children:Object(d.jsx)("b",{children:"xxxxxxx"})}),Object(d.jsx)("li",{children:Object(d.jsx)("b",{children:"xxxxxxxsecure su"})})]}),Object(d.jsx)("p",{children:"This process can be repeated for for each block until all are decrypted"}),Object(d.jsx)("br",{}),Object(d.jsxs)("p",{children:["If you want to try and work this out yourself you can try with a hidden message below. It has a fixed ",Object(d.jsx)("b",{children:"IV"}),", has an alphabet of lowercase letters and space, and is 24 characters long."]}),Object(d.jsx)("p",{children:Object(d.jsx)("i",{children:"Hint: Once you have the first few characters you can start guessing what the flag is to speed up finding new characters."})}),Object(d.jsx)("br",{}),x(!0,"well done for solving it"),Object(d.jsx)("br",{}),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"This process can be automated by a script and I've written one in python that can solve this problem very fast. Below is the full code."}),Object(d.jsx)("br",{}),Object(d.jsxs)(a.a,{children:[Object(d.jsx)("h4",{children:"responder.py"}),Object(d.jsx)("div",{className:"code",children:Object(d.jsx)("code",{className:"prettyprint",children:'import socket\n\nHOST = \'127.0.0.1\'  # The server\'s hostname or IP address\nPORT = 65432        # The port used by the server\n\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n    s.connect((HOST, PORT))\n    iv = s.recv(4096)\n\n    print(\'IV: \', iv.hex())\n\n    secret = ""\n    block = 0\n\n    decoding = True\n\n    while decoding: # decodes one block at a time\n        try:\n            for unknownchar in range(16): # each unknown character in the block\n                test = (15 - unknownchar) * "x"\n                print("Testing with: " + test + secret + "_")\n                s.sendall(iv + str.encode(test))\n                response = s.recv(4096)\n                iv = response[-16:]\n                target = response[(block+1)*16:(block+2)*16] # block we are trying to match\n                found = False\n                for possibleChar in "ABCDEFGHIJKLMNOPQRSTUVWXYZ ": # check all possible characters\n                    message = (15 - unknownchar) * "x" + secret + possibleChar # our guess\n                    s.sendall(iv + str.encode(message))\n                    response = s.recv(4096)\n                    iv = response[-16:] # update the next iv\n                    if target == response[(block+1)*16:(block+2)*16]:\n                        secret += possibleChar # if blocks match then char is correct\n                        print("Secret found so far: " + secret)\n                        found = True\n                        break\n                if not found:\n                    decoding = False\n            block += 1\n        except:\n            break\n\n    print("\nSecret: " + secret)\n'})})]})]})}}}]);
//# sourceMappingURL=3.87178708.chunk.js.map