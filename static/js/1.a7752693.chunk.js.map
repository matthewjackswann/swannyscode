{"version":3,"sources":["writeups/HTB/insaneBolt.jsx","writeups/HTB/insaneBolt0.png","writeups/HTB/insaneBolt1.png","writeups/HTB/insaneBolt2.png"],"names":["Component","className","style","textAlign","src","image0","alt","image1","image2"],"mappings":"mHAAA,0DA4JeA,UAtJf,WAEI,OAAO,gCACH,6CAAoB,uBACpB,+GAAqF,uBACrF,8GACA,qBAAKC,UAAU,OAAOC,MAAO,CAACC,UAAW,UAAzC,SACI,kSAIJ,mGACA,qBAAKF,UAAU,OAAf,SACI,4DAIJ,+EACA,qBAAKG,IAAKC,UAAQC,IAAI,2DACtB,kEACA,qBAAKF,IAAKG,UAAQD,IAAI,iEACtB,0DACA,qBAAKF,IAAKI,UAAQF,IAAI,iEAAiE,uBACvF,wIAIA,4IAGI,uBACJ,2MAGI,uBACJ,mYAMA,sUAII,uBACJ,8JAGI,uBACJ,yDAA+B,uBAC/B,eAAC,IAAD,WACI,8CACA,qBAAKL,UAAU,OAAf,SACZ,sBAAMA,UAAU,cAAhB,o0F,iCC5DA,OAAe,g9J,iCCAf,OAAe,cAA0B,yC,iCCAzC,OAAe,cAA0B","file":"static/js/1.a7752693.chunk.js","sourcesContent":["import React from \"react\";\nimport DropDown from \"../../DropDown\";\nimport image0 from \"./insaneBolt0.png\";\nimport image1 from \"./insaneBolt1.png\";\nimport image2 from \"./insaneBolt2.png\";\n\nfunction Component() { \n\n    return <div>\n        <h1>Insane Bolt</h1><br />\n        <p>This is one of the miscellaneous challenges in the HTB Uni CTF Qualifiers 2021</p><br />\n        <p>We are only given an ip address, a port number and the following description:</p>\n        <div className=\"code\" style={{textAlign: \"center\"}}>\n            <code>\n            {`This insane scientist wants to craft the most powerful android in the world! Help him collect many 🔩 to achieve his goal. Also, he needs many 💎 to make it even more strong and pwoerful than any other android. Good luck adventurer!`}\n            </code>\n        </div>\n        <p>First I tried connecting to the server using a tool called netcat.</p>\n        <div className=\"code\">\n            <code>\n            {`nc <ip_address> <port>`}\n            </code>\n        </div>\n        <p>This was successful and I received the prompt:</p>\n        <img src={image0} alt=\"a menu screen with options for instructions or to play\"/>\n        <p>The instructions page looks like:</p>\n        <img src={image1} alt=\"help the robot reach the diamond following the shortest path\" />\n        <p>And when you choose play:</p>\n        <img src={image2} alt=\"a maze with the robot at the top and a diamond at the bottom\" /><br />\n        <p>\n            When entering the path of the maze if you take too long or are incorrect then the \n            connection is closed.\n        </p>\n        <p>\n            It's a simple case of writing a script that will interact with the server to automatically\n            solve the mazes.\n        </p><br />\n        <p>\n            I first wrote a python script that connects to the port and reads off the first maze. I then \n            turns turns the maze into a 2d array which can be searched to solve the maze.\n        </p><br />\n        <p>\n            To solve the maze I decided to use a breadth-first search algorithm, where from the starting\n            point in looks at all of the starting points neighbours. It then looks at all of their neighbours\n            that haven't already been considered. This continues until the end is found. If the end is not connected\n            to the start the maze is impossible and the program exits.\n        </p>\n        <p>\n            To map the path the robot should take at each step of the BFS algorithm, each new position saves which\n            neighbour it has come from. This mean that from the end we can look at the step before that, the step\n            before the step before that and so on. This continues until we return back to the start.\n        </p><br />\n        <p>\n            All that is required to do now is save this sequence and send it to the server. Then we can receive the \n            next maze and repeat.\n        </p><br />\n        <p>The full script is below</p><br />\n        <DropDown>\n            <h4>responder.py</h4>\n            <div className=\"code\">\n<code className=\"prettyprint\">\n{`import socket\nimport sys\n\nHOST = 'HOST'\nPORT = int('PORT')\n\nborder = '🔥'\nwall = '☠️'\nplayer = '🤖'\npath = '🔩'\nend = '💎'\n\ndef findStart(grid):\n    for x in range(len(grid[1])): # start is always in row 1 of the grid\n        if grid[1][x] == player:\n            return (x,1)\n\ndef checkNeighbor(x, y, parent, visited, toVisit, trace, finished):\n    neighbour = (x, y)\n    if not neighbour in visited:\n        n = grid[y][x]\n        if n == path:\n            toVisit.append(neighbour)\n            visited.append(neighbour)\n            trace[neighbour] = parent\n        if n == end:\n            toVisit = [] # quits loop\n            trace[neighbour] = parent\n            finished.append(neighbour)\n\ndef bfs(grid, start):\n    visited = []\n    toVisit = [start]\n    trace = {}\n    finished = []\n    while len(toVisit) > 0:\n        x, y = toVisit.pop(0)\n        for dx in range(-1,2):\n            checkNeighbor(x + dx, y, (x, y), visited, toVisit, trace, finished)\n        checkNeighbor(x, y + 1, (x, y), visited, toVisit, trace, finished)\n    return (trace, finished)\n\n\ndef removeSpaces(s):\n    return s.replace(\" \", \"\").replace(u\"\\ufe0f\", \"\") # removes padding and charater formatting\n\nwith socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n    s.connect((HOST, PORT))\n    # get instructions. these are the same each time but are included for clarity\n    data = s.recv(1024)\n    print(data.decode(), end=\"\")\n    s.sendall(str.encode(\"1\\n\"))\n    print(\"1\")\n    data = s.recv(1024)\n    # gets first grid from server\n    print(data.decode(), end=\"\")\n    s.sendall(str.encode(\"2\\n\"))\n    print(\"2\")\n    data = s.recv(4096)\n    print(data.decode(), end=\"\")\n    grid = data.decode().strip().split(\"\\n\")[:-2]\n    grid = list(map(removeSpaces, grid))\n    while True: # continue looping till an error is thrown\n        start = findStart(grid)\n        trace, finished = bfs(grid, start)\n        if (len(finished) != 1):\n            print(\"Shouldn't ever happen\")\n            sys.exit()\n        route = \"\"\n        currentNode = finished[0]\n        while currentNode != start: # traces from end to start\n            cx, cy = currentNode\n            px, py = trace[currentNode] # parent node\n            direction = \"\"\n            if px - 1 == cx:\n                direction = \"L\"\n            if px + 1 == cx:\n                direction = \"R\"\n            if py + 1 == cy:\n                direction = \"D\"\n            route = direction + route\n            currentNode = trace[currentNode]\n        s.sendall(str.encode(route + \"\\n\"))\n        print(route)\n        data = s.recv(100000)\n        print(data.decode(), end=\"\")\n        grid = data.decode().strip().split(\"\\n\")[3:-2]\n        grid = list(map(removeSpaces, grid))\n`}\n</code>\n            </div>\n        </DropDown>\n    </div>\n}\n\nexport default Component;\n","export default \"data:image/png;base64,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\"","export default __webpack_public_path__ + \"static/media/insaneBolt1.893e7a57.png\";","export default __webpack_public_path__ + \"static/media/insaneBolt2.e263db8e.png\";"],"sourceRoot":""}